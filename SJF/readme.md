模拟实现SJF
=======

----------------------------------------------------------------------------------------
SJF算法首先调度已到达的任务中，服务时间最短的任务，这里不要求实现任务的抢占。
按照FCFS算法的要求实现SJF算法，同样要求处理两种情况：
当只有一个处理队列时的情况
当有两个处理队列时的情况

--------------------------------------------------------------------------------------------
### 主要描述：
##### task.java 描述了任务的基本属性，作为整个工程的父类。在工程目录中调用了FileOutputStream，生成了time.txt文件。


##### sjfone描述了当一个处理队列时的情况，继承了task。首先调用 FileInputStream，read文件中的数据，赋初值，然后使用循环语句判断任务服务时间的长短，之后再进行其他属性的计算。

##### sjftwo描述了当两个处理队列的情况，继承了task. 设两个整形数据 FirstTime和SecondTime表示第一线程和第二线程的时间。ID初始值为false。for循环选出当前到达的任务中服务时间最短的任务。if条件判断该任务在哪个队列进行。完成的任务ID值=TRUE

##### test 作为测试类输出结果 :switch..case，选择进行单队列的还是双队列。
  

### 实验结果截图：
 
1. 一个队列：<br>
![](https://github.com/123012013021/javaSpace/blob/master/SJF/img/1.png)<br>
2. 两个队列：<br>
![](https://github.com/123012013021/javaSpace/blob/master/SJF/img/2.png)<br>


